<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">

    <meta name="author" content="Joachim Wiberg">
    <meta name="description" content="watchdogd(8) is an advanced system and process supervisor daemon, primarily intended for embedded Linux and server systems. By default it periodically kicks the system watchdog timer (WDT) to prevent it from resetting the system. In its more advanced guise it monitors critical system resources, supervises the heartbeat of processes, records deadline transgressions, and initiates a controlled reset if needed.
When a system comes back up after a reset, watchdogd determines the reset cause and records it in a file for later analysis by an operator or network management system (NMS).">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="System &amp; Process Supervisor for Linux"/>
<meta name="twitter:description" content="watchdogd(8) is an advanced system and process supervisor daemon, primarily intended for embedded Linux and server systems. By default it periodically kicks the system watchdog timer (WDT) to prevent it from resetting the system. In its more advanced guise it monitors critical system resources, supervises the heartbeat of processes, records deadline transgressions, and initiates a controlled reset if needed.
When a system comes back up after a reset, watchdogd determines the reset cause and records it in a file for later analysis by an operator or network management system (NMS)."/>

    <meta property="og:title" content="System &amp; Process Supervisor for Linux" />
<meta property="og:description" content="watchdogd(8) is an advanced system and process supervisor daemon, primarily intended for embedded Linux and server systems. By default it periodically kicks the system watchdog timer (WDT) to prevent it from resetting the system. In its more advanced guise it monitors critical system resources, supervises the heartbeat of processes, records deadline transgressions, and initiates a controlled reset if needed.
When a system comes back up after a reset, watchdogd determines the reset cause and records it in a file for later analysis by an operator or network management system (NMS)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://troglobit.com/projects/watchdogd/" />
<meta property="article:published_time" content="2019-05-27T21:46:00+02:00" />
<meta property="article:modified_time" content="2019-05-27T21:46:00+02:00" />


    <title>
  System &amp; Process Supervisor for Linux · The Last Outpost
</title>

    
      <link rel="canonical" href="https://troglobit.com/projects/watchdogd/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.1.7/css/fork-awesome.min.css" integrity="sha256-gsmEoJAws/Kd3CjuOQzLie5Q3yshhvmo7YNtBG7aaEY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://troglobit.com/css/coder.min.9836c03fe5c87d102278a33e86d0591ef36c89b1e17e8e547ebf84c05cee010e.css" integrity="sha256-mDbAP&#43;XIfRAieKM&#43;htBZHvNsibHhfo5Ufr&#43;EwFzuAQ4=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="https://troglobit.com/css/coder-dark.min.717236c74e0a5208ef73964a9f44c6b443b689a95b270d8b2a40d0c012460dac.css" integrity="sha256-cXI2x04KUgjvc5ZKn0TGtEO2ialbJw2LKkDQwBJGDaw=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="https://troglobit.com/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://troglobit.com/favicon.ico" sizes="16x16">

    <link rel="apple-touch-icon" href="https://troglobit.com/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://troglobit.com/images/apple-touch-icon.png">

    

    <meta name="generator" content="Hugo 0.68.3" />
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=""
  >
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://troglobit.com/">
      The Last Outpost
    </a>
    
      
        <span id="dark-mode-toggle" class="float-right">
          <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
        </span>
      
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://troglobit.com/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://troglobit.com/post/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://troglobit.com/howto/">HowTos</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://troglobit.com/projects/">Projects</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://resume.troglobit.com">Resumé</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://ftp.troglobit.com">FTP</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://git.troglobit.com">GIT</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://deb.troglobit.com">DEB</a>
            </li>
          
        
        
        
          <li class="navigation-item separator">
            <span>|</span>
          </li>
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>System &amp; Process Supervisor for Linux</h1>
    </header>

    <p><!-- raw HTML omitted --></p>
<p><code>watchdogd(8)</code> is an advanced system and process supervisor daemon,
primarily intended for embedded Linux and server systems.  By default it
periodically kicks the system watchdog timer (WDT) to prevent it from
resetting the system.  In its more advanced guise it monitors critical
system resources, supervises the heartbeat of processes, records
deadline transgressions, and initiates a controlled reset if needed.</p>
<p>When a system comes back up after a reset, <code>watchdogd</code> determines the
reset cause and records it in a file for later analysis by an operator
or network management system (NMS).  This information in turn can be
used to put the system in an operational safe state, or non-operational
safe state.</p>
<h3 id="what-is-a-watchdog-timer">What is a watchdog timer?</h3>
<p>Most server and laptop motherboards today come equipped with a watchdog
timer (WDT).  It is a small timer connected to the reset circuitry so
that it can reset the board if the timer expires.  The WDT driver, and
this daemon, periodically &ldquo;kick&rdquo; (reset) the timer to prevent it from
firing.</p>
<p>Most embedded systems utilise watchdog timers as a way to automatically
recover from malfunctions: lock-ups, live-locks, CPU overload.  With a
bit of logic sprinkled on top the cause can more easily be tracked down.</p>
<p>The Linux kernel provides a common userspace interface <code>/dev/watchdog</code>,
created automatically when the appropriate watchdog driver is loaded.
If your board does not have a WDT, the kernel provides a <code>softdog.ko</code>
module which in many cases can be good enough.</p>
<p>The idea of a watchdog daemon in userspace is to run in the background
of your system.  When there is no more CPU time for the watchdog daemon
to run it will fail to &ldquo;kick&rdquo; the WDT.  This will in turn cause the WDT
to reboot the system.  When it does <code>watchdogd</code> have already saved the
reset cause for your post mortem.</p>
<p>As a background process, <code>watchdogd</code> can of course also be used to
monitor other aspects of the system &hellip;</p>
<h3 id="what-can-watchdogd-do">What can watchdogd do?</h3>
<p>Without arguments <code>watchdogd</code> runs in the background, monitoring the the
CPU, and as long as there is CPU time it &ldquo;kicks&rdquo; the WDT chip (via the
driver).  If <code>watchdogd</code> is stopped, or does not get enough CPU time to
run, the WDT will detect this and reboot the system.  This is the normal
mode of operation.</p>
<p>With a few lines in <code>/etc/watchdogd.conf</code>, it can also monitor other
aspects of the system, such as:</p>
<ul>
<li>Load average</li>
<li>Memory leaks</li>
<li>File descriptor leaks</li>
<li>Process live locks</li>
<li>Reset counter, for snmpEngineBoots (RFC 2574)</li>
</ul>
<p>To top things off there is support for periodically calling a generic
script where operators can do housekeeping checks.  For details on how
to configure this, see the watchdogd.conf(5) man page.</p>
<h2 id="usage">Usage</h2>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">watchdogd [-hnsVx] [-f FILE] [-T SEC] [-t SEC] [/dev/watchdog]

Options:
  -f, --config=FILE        Use FILE for daemon configuration
  -n, --foreground         Start in foreground (background is default)
  -s, --syslog             Use syslog, even if running in foreground
  -l, --loglevel=LVL       Log level: none, err, info, notice*, debug
  
  -T, --timeout=SEC        HW watchdog timer (WDT) timeout in SEC seconds
  -t, --interval=SEC       WDT kick interval in SEC seconds, default: 10
  -x, --safe-exit          Disable watchdog on exit from SIGINT/SIGTERM
                           &#34;magic&#34; exit may not be supported by HW/driver
  
  -V, --version            Display version and exit
  -h, --help               Display this help message and exit
</code></pre></div><p>Without any arguments, <code>watchdogd</code> opens <code>/dev/watchdog</code>, forks to the
background, tries to to set a 20 sec WDT timeout, and then kicks every
10 sec.  See the <a href="#operation">Operation</a> section for more information.</p>
<p><strong>Example</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">watchdogd -T <span style="color:#3677a9">120</span> -t <span style="color:#3677a9">30</span> /dev/watchdog2
</code></pre></div><p><code>watchdogd</code> runs at the default UNIX priority (nice) level, unless the
process monitor is activated, in which case it runs at an elevated real
time priority.</p>
<h2 id="features">Features</h2>
<p>To force a kernel watchdog reboot, <code>watchdogd</code> supports <code>SIGPWR</code>, used
by some <code>init(1)</code> systems to delegate a reboot.  What it does is to set
the WDT timer to the lowest possible value (1 sec), close the connection
to <code>/dev/watchdog</code>, and wait for WDT reboot.  It waits at most 3x the
WDT timeout before announcing HW WDT failure and forcing a reboot.</p>
<p><code>watchdogd(8)</code> supports optional monitoring of several system resources
that can be enabled in the <code>.conf</code> file.  First, system load average
monitoring can be enabled with:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">loadavg {
    interval = 300       # Every 5 mins
    warning  = 1.5
    critical = 2.0
}
</code></pre></div><p>Second, the memory leak detector, a value of 1.0 means 100% memory use:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">meminfo {
    interval = 3600       # Every hour
    warning  = 0.9
    critical = 0.95
}
</code></pre></div><p>Third, file descriptor leak detector:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">filenr {
    interval = 3600       # Every hour
    warning  = 0.8
    critical = 0.95
}
</code></pre></div><p>All of these monitors can be <em>very</em> useful on an embedded or headless
system with little or no operator.</p>
<p>The two values, <code>warning</code> and <code>critical</code>, are the warning and reboot
levels in percent.  The latter is optional, if it is omitted reboot is
disabled.  A script can also be run instead of reboot, see the <code>.conf</code>
file for details.</p>
<p>Determining suitable system load average levels is tricky.  It always
depends on the system and use-case, not just the number of CPU cores.
Peak loads of 16.00 on an 8 core system may be responsive and still
useful but 2.00 on a 2 core system may be completely bogged down.  Make
sure to read up on the subject and thoroughly test your system before
enabling a reboot trigger value.  <code>watchdgod</code> uses an average of the
first two load average values, the one (1) and five (5) minute.</p>
<p>The RAM usage monitor only triggers on systems without swap.  This is
detected by reading the file <code>/proc/meminfo</code>, looking for the
<code>SwapTotal:</code> value.</p>
<p><code>watchdogd</code> v2.0 and later comes with a process supervisor (previously
called pmon).  When the supervisor is enabled the daemon runs as a
real-time task with the configured priority, default 98.  Monitored
clients connect to the supervisor using the libwdog API.</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">supervisor {
    enabled = true
    priority = 98
}
</code></pre></div><p><a href="#libwdog-api">See below</a> for details on how to have your process
internal deadlines be supervised.</p>
<p>When a process fails to meet its deadlines, or a monitor plugin reaches
critical level, <code>watchdogd</code> initiates a controlled reset.  To see the
reset cause after reboot, the following section must be enabled in the
<code>/etc/watchdogd.conf</code> file:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">reset-cause {
    enabled = true
#   file    = /var/lib/watchdogd.state
}
</code></pre></div><p>The <code>file</code> setting is optional, the default is usually sufficient, but
make sure the destination directory is writable if you change it.</p>
<h2 id="libwdog-api">libwdog API</h2>
<p>To use pmon a client must have its source code instrumented with at
least a &ldquo;subscribe&rdquo; and a &ldquo;kick&rdquo; call.  Commonly this is achieved by
adding the <code>wdog_kick2()</code> call to the main event loop.</p>
<p>All API calls, except <code>wdog_ping()</code>, return POSIX OK(0) or negative
value with <code>errno</code> set on error.  The <code>wdog_subscribe()</code> call returns a
positive integer (including zero) for the watchdog <code>id</code>.</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#999;font-style:italic">/*
</span><span style="color:#999;font-style:italic"> * Enable or disable watchdogd at runtime.
</span><span style="color:#999;font-style:italic"> */</span>
<span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">wdog_enable</span>      (<span style="color:#6ab825;font-weight:bold">int</span> enable);
<span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">wdog_status</span>      (<span style="color:#6ab825;font-weight:bold">int</span> *enabled);

<span style="color:#999;font-style:italic">/*
</span><span style="color:#999;font-style:italic"> * Check if watchdogd API is actively responding,
</span><span style="color:#999;font-style:italic"> * returns %TRUE(1) or %FALSE(0)
</span><span style="color:#999;font-style:italic"> */</span>
<span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">wdog_ping</span>        (<span style="color:#6ab825;font-weight:bold">void</span>);

<span style="color:#999;font-style:italic">/*
</span><span style="color:#999;font-style:italic"> * Register with pmon, timeout in msec.  Return value is the `id`
</span><span style="color:#999;font-style:italic"> * to be used with the `ack` in subsequent kick()/unsubscribe()
</span><span style="color:#999;font-style:italic"> */</span>
<span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">wdog_subscribe</span>   (<span style="color:#6ab825;font-weight:bold">char</span> *label, <span style="color:#6ab825;font-weight:bold">int</span> timeout, <span style="color:#6ab825;font-weight:bold">int</span> *ack);
<span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">wdog_unsubscribe</span> (<span style="color:#6ab825;font-weight:bold">int</span> id, <span style="color:#6ab825;font-weight:bold">int</span> ack);
<span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">wdog_kick2</span>       (<span style="color:#6ab825;font-weight:bold">int</span> id, <span style="color:#6ab825;font-weight:bold">int</span> *ack);
</code></pre></div><p>It is highly recommended to use an event loop like libev, <a href="https://github.com/troglobit/libuev/">libuev</a>, or
similar.  For such libraries one can simply add a timer callback for the
kick to run periodically to monitor proper operation of the client.</p>
<h3 id="example">Example</h3>
<p>For other applications, identify your main loop, its max period time and
instrument it like this:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6ab825;font-weight:bold">int</span> ack, wid;

<span style="color:#999;font-style:italic">/* Library will use process&#39; name on NULL first arg. */</span>
wid = wdog_subscribe(<span style="color:#24909d">NULL</span>, <span style="color:#3677a9">10000</span>, &amp;ack);
<span style="color:#6ab825;font-weight:bold">if</span> (-<span style="color:#3677a9">1</span> == wid)
        ;      <span style="color:#999;font-style:italic">/* Error handling */</span>

<span style="color:#6ab825;font-weight:bold">while</span> (<span style="color:#3677a9">1</span>) {
        ...
        wdog_kick2(wid, &amp;ack);
        ...
}
</code></pre></div><p>This simple example subscribes to the watchdog with a 10 sec timeout.
The received <code>wid</code> is used in the call to <code>wdog_pmon_kick()</code>, along with
the received <code>ack</code> value.  Which is changed every time the application
calls <code>wdog_pmon_kick()</code>.  The application should of course check the
return value of <code>wdog_pmon_subscribe()</code> for errors, that code is left
out of the example to make it easier to read.</p>
<p>See also the <a href="https://github.com/troglobit/watchdogd/blob/master/examples/ex1.c">example/ex1.c</a> in the source distribution.  This is
used by the automatic tests.</p>
<h2 id="operation">Operation</h2>
<p>By default, <code>watchdogd</code> forks off a daemon in the background, opens the
<code>/dev/watchdog</code> device, attempts to set the default WDT timeout to 20
seconds and then goes into an endless loop where it kicks the watchdog
every 10 seconds.</p>
<p>If a device driver does not support setting the WDT timeout, <code>watchdogd</code>
attempts to query the actual (possibly hard coded) watchdog timeout and
then uses half that time as the kick interval.</p>
<p>When <code>watchdogd</code> backgrounds itself syslog is implicitly used for all
informational and debug messages.  If a user requests to run the daemon
in the foreground <code>watchdogd</code> will also log to <code>STDERR</code> and <code>STDOUT</code>,
unless the user gives the <code>--syslog</code> argument to force use of syslog.</p>
<h2 id="debugging">Debugging</h2>
<p>The code has both <code>INFO()</code> and <code>DEBUG()</code> statements sprinkled almost
everywhere.  Use the <code>--loglevel=debug</code> command line option to enable
full debug output to stderr or the syslog, depending on how you start
<code>watchdogd</code>.</p>
<h2 id="build--install">Build &amp; Install</h2>
<p><code>watchdogd</code> is tailored for Linux systems and should build against any C
libray.  v2.1 and later require a few external libraries: <a href="https://github.com/troglobit/libite/">libite</a>,
<a href="https://github.com/troglobit/libuev/">libuEv</a>, and [libConfuse][].  Neither should present any surprises,
all use de facto standard <code>configure</code> scripts and support <code>pkg-config</code>
which the <code>watchdogd</code> <code>configure</code> script use to locate libraries and
header files.</p>
<p>Hence, the regular <code>./configure &amp;&amp; make</code> is usually sufficient to build
<code>watchdogd</code>.  But, if libraries are installed in non-standard locations
you may need to provide their paths:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#40ffff">PKG_CONFIG_PATH</span>=/opt/lib/pkgconfig:/home/ian/lib/pkgconfig ./configure
make
</code></pre></div><p>To build the source from GIT, see below.</p>
<h2 id="origin--references">Origin &amp; References</h2>
<p><code>watchdogd(8)</code> is an improved version of the original, created by
Michele d&rsquo;Amico and adapted to <a href="http://www.uclinux.org/pub/uClinux/dist/">uClinux-dist</a> by Mike Frysinger.  It
is maintained by <a href="http://troglobit.com">Joachim Nilsson</a> collaboratively at <a href="http://github.com/troglobit/watchdogd">GitHub</a>.</p>
<p>The <a href="http://www.mail-archive.com/uclinux-dev@uclinux.org/msg04191.html">original code</a> in uClinux-dist is available in the public domain,
whereas this version is distributed under the ISC license.  See the
file <a href="https://github.com/troglobit/watchdogd/blob/master/LICENSE">LICENSE</a> for more details on this.</p>
<p>The <a href="https://www.clipartof.com/435776">logo</a>, &ldquo;Watch Dog Detective Taking Notes&rdquo;, is licensed for use by
the <code>watchdogd</code> project, copyright © <a href="http://toonclips.com/design/788">Ron Leishman</a>.</p>
<p>Issue tracker and GIT repository available at GitHub:</p>
<ul>
<li><a href="http://github.com/troglobit/watchdogd">Repository</a></li>
<li><a href="https://github.com/troglobit/watchdogd/blob/master/ChangeLog.md">ChangeLog</a></li>
<li><a href="https://github.com/troglobit/watchdogd/blob/master/README.md">README</a></li>
<li><a href="https://github.com/troglobit/watchdogd/blob/master/docs/TODO.md">TODO</a></li>
<li><a href="http://github.com/troglobit/watchdogd/issues">Issue Tracker</a></li>
<li><a href="ftp://ftp.troglobit.com/watchdogd/watchdogd-3.2.tar.xz">watchdogd-3.2.tar.xz</a>,
<a href="ftp://ftp.troglobit.com/watchdogd/watchdogd-3.2.tar.xz.md5">MD5</a></li>
</ul>
<h2 id="contributing">Contributing</h2>
<p>If you find bugs or want to contribute fixes or features, check out the
code from GitHub:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone https://github.com/troglobit/watchdogd
<span style="color:#24909d">cd</span> watchdogd
./autogen.sh
</code></pre></div><p>The <code>autogen.sh</code> script runs <code>autoconf</code>, <code>automake</code>, et al to create the
configure script and such generated files not part of the VCS tree.  For
more details, see the file <a href="https://github.com/troglobit/watchdogd/blob/master/CONTRIBUTING.md">CONTRIBUTING</a>.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->

  </article>
</section>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js" id="MathJax-script"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ['$', '$'], ['\\(', '\\)']
        ],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>

      </div>

      
  <footer class="footer">
    <section class="container">
      
      
        ©
        
        2020
         Joachim Wiberg 
      
      
      
    </section>
  </footer>

    </main>

    
      
      <script src="https://troglobit.com/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js"></script>
    

    

    

    

    

    
  </body>

</html>
