<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unix on Troglobit</title>
    <link>/categories/unix/</link>
    <description>Recent content in Unix on Troglobit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>troglobit@gmail.com (Joachim Nilsson)</managingEditor>
    <webMaster>troglobit@gmail.com (Joachim Nilsson)</webMaster>
    <lastBuildDate>Sat, 02 Jul 2016 12:54:37 +0000</lastBuildDate>
    
	<atom:link href="/categories/unix/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Redirecting Ports For Fun and Profit</title>
      <link>/2016/07/02/redirecting-tcp-udp-ports-for-fun-and-profit/</link>
      <pubDate>Sat, 02 Jul 2016 12:54:37 +0000</pubDate>
      <author>troglobit@gmail.com (Joachim Nilsson)</author>
      <guid>/2016/07/02/redirecting-tcp-udp-ports-for-fun-and-profit/</guid>
      <description>&lt;p&gt;Recently I needed a simple TCP/UDP port redirector and stumbled upon
&lt;a href=&#34;https://serverfault.com/questions/252150/port-forwarding-on-linux-without-iptables/&#34;&gt;this Stackoverflow post&lt;/a&gt;.  As usual I wasn&amp;rsquo;t first wanting to this
without using &lt;code&gt;iptables&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There were several alternatives, but since my target was embedded with
limited amount of RAM and flash I wanted something really small.  So the
best fit turned out to be &lt;a href=&#34;https://github.com/troglobit/redir&#34;&gt;redir&lt;/a&gt;, which unfortunately only could
handle TCP connections.  This is what led me to write &lt;a href=&#34;https://github.com/troglobit/uredir&#34;&gt;uredir&lt;/a&gt; to
complement &lt;code&gt;redir&lt;/code&gt;.  Eventually I ended up adoptiing &lt;code&gt;redir&lt;/code&gt; as well,
which meant giving it a bit of a facelift and to give them both the same
look and feel.&lt;/p&gt;

&lt;p&gt;Currently they are two separate applications, which in some use-cases
can be beneficial (small size), but I may in the future transplant the
UDP functionality of &lt;code&gt;uredir&lt;/code&gt; into &lt;code&gt;redir&lt;/code&gt;.  We&amp;rsquo;ll see, right now though
I have several other &lt;a href=&#34;/projects/&#34;&gt;projects&lt;/a&gt; to attend to :-)&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Using netcat to test your Internet daemon</title>
      <link>/2016/04/21/using-netcat-to-test-your-internet-daemon/</link>
      <pubDate>Thu, 21 Apr 2016 14:21:49 +0000</pubDate>
      <author>troglobit@gmail.com (Joachim Nilsson)</author>
      <guid>/2016/04/21/using-netcat-to-test-your-internet-daemon/</guid>
      <description>So you&amp;rsquo;re having a problem with the Internet daemon you wrote. You&amp;rsquo;re convinced the firewall, or some other magic, in your modern Linux distribution is eating your packets.
No.
First, make sure your daemon is actually running and has successfully bound to the address and port in question:
sudo netstat -atnup  If your application is not listed there you have a problem with it binding its server socket. Check the return values from bind().</description>
    </item>
    
    <item>
      <title>The key to successful boot</title>
      <link>/2016/04/11/the-key-to-successful-boot/</link>
      <pubDate>Mon, 11 Apr 2016 01:28:27 +0000</pubDate>
      <author>troglobit@gmail.com (Joachim Nilsson)</author>
      <guid>/2016/04/11/the-key-to-successful-boot/</guid>
      <description>&lt;p&gt;How do you know when your UNIX service (daemon) is ready?  Simple, it
has created a PID file, signalling to you how to reach it.  Usually this
file is created as &lt;code&gt;/var/run/daemon.pid&lt;/code&gt;, or &lt;code&gt;/run/daemon.pid&lt;/code&gt;, and has
the PID of &lt;code&gt;daemon&lt;/code&gt; as the first and only data in the file.  This data
may or may not have a UNIX line ending.&lt;/p&gt;

&lt;p&gt;Only trouble is: most UNIX daemons do not re-assert that PID file
properly on &lt;code&gt;SIGHUP&lt;/code&gt; (if they support &lt;code&gt;SIGHUP&lt;/code&gt; that is).  When I send
&lt;code&gt;SIGHUP&lt;/code&gt; to a daemon I expect it to re-read its &lt;code&gt;/etc/daemon.conf&lt;/code&gt; and
resume operation, basically a quicker way than stop/start.&lt;/p&gt;

&lt;p&gt;Annoyingly however, most daemons do not signal us back to tell us when
they&amp;rsquo;re done with the &lt;code&gt;SIGHUP&lt;/code&gt;.  Naturally a new movement has risen that
says we should all instrument our daemons with D-bus &amp;hellip; I say no.
Simply touch the PID file instead.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Testing multicast with Docker</title>
      <link>/2016/03/07/testing-multicast-with-docker/</link>
      <pubDate>Mon, 07 Mar 2016 01:37:04 +0000</pubDate>
      <author>troglobit@gmail.com (Joachim Nilsson)</author>
      <guid>/2016/03/07/testing-multicast-with-docker/</guid>
      <description>&lt;p&gt;Recently &lt;a href=&#34;https://github.com/troglobit/pimd/issues/70&#34;&gt;issue #70&lt;/a&gt; was
reported to &lt;a href=&#34;https://github.com/troglobit/pimd/&#34;&gt;pimd&lt;/a&gt;.  That number of
issues reported is cool in itself, but this was a question about
&lt;a href=&#34;https://www.docker.com&#34;&gt;Docker&lt;/a&gt; and &lt;code&gt;pimd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Up until that point I had only read about this new fad, and played
around with it a bit &lt;a href=&#34;http://www.westermo.com&#34;&gt;at work&lt;/a&gt; for use as a
stable build environment for cross-compiling.  I had no idea people
would want to use a Docker container as a multicast sink.  Basically I
was baffled.&lt;/p&gt;

&lt;p&gt;The reporter used a Java based tool but simply couldn&amp;rsquo;t get things to
work properly with &lt;code&gt;pimd&lt;/code&gt; running on the host:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                eth0
 MC sender ---&amp;gt; [ Server host ]    &amp;lt;--- router running pimd
                       |
               ________|________
              /     docker0     \   &amp;lt;--- bridge    ______
             /         |         \                |      |   &amp;lt;--- MC receiver
  __________/          |          \_______________|______|_____
 \                     |                            /         /
  \                     `------------------&amp;gt;-------&#39;         /
   \________________________________________________________/
      Container ship
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Multicast testing, made easy!</title>
      <link>/2016/03/07/multicast-testing/</link>
      <pubDate>Mon, 07 Mar 2016 01:06:02 +0000</pubDate>
      <author>troglobit@gmail.com (Joachim Nilsson)</author>
      <guid>/2016/03/07/multicast-testing/</guid>
      <description>&lt;p&gt;For the better part of the last ten years I have been working with
multicast in one way or another.  I&amp;rsquo;ve used many different tools for
testing, but on most systems I usually resort to &lt;code&gt;ping(1)&lt;/code&gt; and
&lt;code&gt;tcpdump(1)&lt;/code&gt;, which are quite sufficient.  However, you often need to
tell bridges (switches) to open up multicast in your general direction
for your pings to get through, so you need to send an IGMP &amp;ldquo;join&amp;rdquo; first.&lt;/p&gt;

&lt;p&gt;Way back in 2006 I stumbled upon a neat tool called &lt;code&gt;mcjoin&lt;/code&gt;, written by
David Stevens and announced in
&lt;a href=&#34;https://lkml.org/lkml/2004/8/5/143&#34;&gt;this posting to LKML&lt;/a&gt;.  I started
improving and adding features to it over the years.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>