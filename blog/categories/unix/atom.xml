<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Unix | Troglobit]]></title>
  <link href="http://troglobit.github.io/blog/categories/unix/atom.xml" rel="self"/>
  <link href="http://troglobit.github.io/"/>
  <updated>2016-04-11T01:49:14+02:00</updated>
  <id>http://troglobit.github.io/</id>
  <author>
    <name><![CDATA[Joachim Nilsson]]></name>
    <email><![CDATA[troglobit@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Key to Successful Boot]]></title>
    <link href="http://troglobit.github.io/blog/2016/04/11/the-key-to-successful-boot/"/>
    <updated>2016-04-11T01:28:27+02:00</updated>
    <id>http://troglobit.github.io/blog/2016/04/11/the-key-to-successful-boot</id>
    <content type="html"><![CDATA[<p>How do you know when your UNIX service (daemon) is ready?  Simple, it
has created a PID file, signalling to you how to reach it.  Usually this
file is created as <code>/var/run/daemon.pid</code>, or <code>/run/daemon.pid</code>, and has
the PID of <code>daemon</code> as the first and only data in the file.  This data
may or may not have a UNIX line ending.</p>

<p>Only trouble is: most UNIX daemons do not re-assert that PID file
properly on <code>SIGHUP</code> (if they support <code>SIGHUP</code> that is).  When I send
<code>SIGHUP</code> to a daemon I expect it to re-read its <code>/etc/daemon.conf</code> and
resume operation, basically a quicker way than stop/start.</p>

<p>Annoyingly however, most daemons do not signal us back to tell us when
they&rsquo;re done with the <code>SIGHUP</code>.  Naturally a new movement has risen that
says we should all instrument our daemons with D-bus &hellip; I say no.
Simply touch the PID file instead.</p>

<p>Yeah, one could argue the natural (and pure) thing would be to add a
UNIX domain socket and use a <code>daemonctl</code> client instead of <code>SIGHUP</code> +
PID file &hellip; but for this little mechanism of signalling back to the
user that a daemon is ready for business, it&rsquo;s too much overhead.</p>

<p>My own Init replacement, <a href="/finit.html">Finit</a>, is being fitted with a
system to synchronize services with events.  Eg. wait for one service to
start, an interface to be created, or come up, or have an address set,
or a gateway to be set &hellip; and so on.</p>

<p>In the case where process B depends on process A you do not want to
start process B before process A is actually up and running.  Simply
starting process A is rarely sufficient &ndash; starting B too soon can
lead to B terminating prematurely because it cannot yet connect to A.</p>

<p>One may argue that B should try and reconnect, or that A and B should
have some other means of synchronizing.  Sure, when dependencies are
clear and developers create cooperating services this works great.  But
this is rarely the case in real life.  Services are usually developed by
multiple teams, scattered across both time and distance.  So what we&rsquo;re
left with is finding the least common denominator and use that for our
synchronization needs.</p>

<p>Waiting for daemon A to create its PID file before we start process B is
enough.  When the system is reconfigured &ndash; many services may need to be
restarted &ndash; we can shake the dependency tree and send <code>SIGHUP</code> to all
daemons in the correct order.  The only patching required is to ensure
that all daemons re-assert their PID files after having reloaded their
respective config files.</p>

<p>More on the changes in Finit3 and the upcoming new dependency systems
in a later article.  Hopefully this will have made you interested!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Multicast With Docker]]></title>
    <link href="http://troglobit.github.io/blog/2016/03/07/testing-multicast-with-docker/"/>
    <updated>2016-03-07T01:37:04+01:00</updated>
    <id>http://troglobit.github.io/blog/2016/03/07/testing-multicast-with-docker</id>
    <content type="html"><![CDATA[<p>Recently <a href="https://github.com/troglobit/pimd/issues/70">issue #70</a> was
reported to <a href="https://github.com/troglobit/pimd/">pimd</a>.  That number of
issues reported is cool in itself, but this was a question about
<a href="https://www.docker.com">Docker</a> and <code>pimd</code>.</p>

<p>Up until that point I had only read about this new fad, and played
around with it a bit <a href="http://www.westermo.com">at work</a> for use as a
stable build environment for cross-compiling.  I had no idea people
would want to use a Docker container as a multicast sink.  Basically I
was baffled.</p>

<p>The reporter used a Java based tool but simply couldn&rsquo;t get things to
work properly with <code>pimd</code> running on the host:</p>

<pre><code>                eth0
 MC sender ---&gt; [ Server host ]    &lt;--- router running pimd
                       |
               ________|________
              /     docker0     \   &lt;--- bridge    ______
             /         |         \                |      |   &lt;--- MC receiver
  __________/          |          \_______________|______|_____
 \                     |                            /         /
  \                     `------------------&gt;-------'         /
   \________________________________________________________/
      Container ship
</code></pre>

<p>We tried several approaches, but nothing seemed to help.  This became a
bit of blocker for the <code>pimd</code> v2.3.2 release and I admittedly lost a bit
of sleep over this.  So finally this weekend, I sat down and whipped my
old <a href="https://github.com/troglobit/mcjoin/">mcjoin</a> tool up into shape.
I&rsquo;ve relied on it for years, but it couldn&rsquo;t send or receive packets,
until now.</p>

<p>Running docker v1.5 in Ubuntu 15.10 I ran this, with <code>pimd</code> on the host
and <code>mcjoin</code> as a multicast sink for 250 groups in a container:</p>

<pre><code>cd ~/Troglobit/mcjoin
docker run -t -i -u `id -u`:`id -g` -v $HOME:$HOME -w $PWD troglobit/toolchain:latest ./mcjoin 225.1.2.3+250
^C
Received total: 2500 packets
</code></pre>

<p>The <code>pimd</code> and the multicast sender runs on my host, which should not
matter since Linux still has to route the traffic to the <code>docker0</code>
interface.  Also, without setting the TTL to 2 (or greater) the
container receives no traffic at all.  Here&rsquo;s what I run in another
terminal on my host:</p>

<pre><code>./mcjoin -s -t 2 -c 10 225.1.2.3+250
</code></pre>

<p>Although <code>pimd</code> is a little slow to register and install the forwarding
rules in the kernel, it sure enough worked on the first attempt! \o/</p>

<p>This is my first real application level experience with Docker, but it
is sure not the last.  Docker is a truly revolutionary new tool!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multicast Testing, Made Easy!]]></title>
    <link href="http://troglobit.github.io/blog/2016/03/07/multicast-testing/"/>
    <updated>2016-03-07T01:06:02+01:00</updated>
    <id>http://troglobit.github.io/blog/2016/03/07/multicast-testing</id>
    <content type="html"><![CDATA[<p>For the better part of the last ten years I&rsquo;ve been working with
multicast in one way or another.  I&rsquo;ve used many different tools for
testing, but usually simply using <code>ping(1)</code> and <code>tcpdump(1)</code> is quite
sufficient.  However, you often need to tell bridges (switches) to open
up multicast in your general direction for your pings to get through, so
you need to send an IGMP &ldquo;join&rdquo; first.  I found mcjoin, written by David
Stevens, in <a href="https://lkml.org/lkml/2004/8/5/143">this posting to LKML</a>
back in 2006, and started improving it and adding features to it over
the years.</p>

<p>Now, my interest and fascination with multicast only grew with time,
and despite elegant tools like <code>mgen(1)</code> and <code>omping(1)</code> I was never
quite happy.</p>

<p>When releasing SMCRoute v2.1.0 recently, and currently working on the
pimd v2.3.2 release, I was so tired of having to do so many manual steps
just to verify correct operation of a routing daemon.  Therefore I spent
the better part of the weekend fixing up my old mcjoin tool.</p>

<p>I wanted a reliable, simple, and UNIX-y tool to just test things for me.
So I cleaned up the old mcjoin project, first by migrating it from the
toolbox repo, then remove confusing command line options, improve and
simplify the syntax, and then added send/receive capabilities.  Been
meaning to get around to this for ages, and now it seems I had finally
had enough.  So here it is, v2.0:</p>

<ul>
<li><strong>Project</strong>: <a href="https://github.com/troglobit/mcjoin/">https://github.com/troglobit/mcjoin/</a></li>
<li><strong>ChangeLog</strong>: <a href="https://github.com/troglobit/mcjoin/releases/tag/v2.0">https://github.com/troglobit/mcjoin/releases/tag/v2.0</a></li>
</ul>


<p>Most of the time I simply want to see a resulting IGMP join message in
Wireshark, see it bite in a switch&rsquo;s FDB or a routing daemon&rsquo;s
forwarding table.  So, join is the default operation, and also continues
to be the name of the tool.  My favourite testing group is set as the
default, 225.1.2.3, so you only need to start the tool and you&rsquo;re off.
To send to the same default group (225.1.2.3), simply add <code>-s</code> to the
sender side.</p>

<pre><code>sender$ mcjoin -s
^C
sender$

receiver$ mcjoin
joined group 225.1.2.3 on eth0 ...
..................................................................^C
Received total: 66 packets
receiver$
</code></pre>

<p>If you ever need anything else, e.g. routing multicast, there&rsquo;s even a
man page.  It mentions setting the TTL and other such nastiness :)</p>
]]></content>
  </entry>
  
</feed>
