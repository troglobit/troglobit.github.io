<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Finit | Troglobit]]></title>
  <link href="http://troglobit.github.io/blog/categories/finit/atom.xml" rel="self"/>
  <link href="http://troglobit.github.io/"/>
  <updated>2015-08-28T12:56:36+02:00</updated>
  <id>http://troglobit.github.io/</id>
  <author>
    <name><![CDATA[Joachim Nilsson]]></name>
    <email><![CDATA[troglobit@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Inetd Support in Finit v1.12]]></title>
    <link href="http://troglobit.github.io/blog/2015/03/06/inetd-support-in-finit-v1-dot-12/"/>
    <updated>2015-03-06T22:34:45+01:00</updated>
    <id>http://troglobit.github.io/blog/2015/03/06/inetd-support-in-finit-v1-dot-12</id>
    <content type="html"><![CDATA[<p>A steady flow of features, and releases, is key to keeping any project
alive.  Recently I ticked off another item in the <a href="/finit.html">Finit</a>
TODO list &hellip;</p>

<p>Finit v1.12 now comes with a built-in inetd!  You no longer need an
external inetd daemon to launch services on demand.</p>

<p>The good news doesn&rsquo;t stop there, this little inetd actually supports a
poor man&rsquo;s tcpwrappers!</p>

<pre><code>inetd ssh/tcp          nowait [2345] /sbin/dropbear -i -R -F
inetd ssh@eth0:222/tcp nowait [2345] /sbin/dropbear -i -R -F
</code></pre>

<p>With these two lines in your <code>/etc/finit.conf</code> you tell finit to launch
the <a href="https://matt.ucc.asn.au/dropbear/dropbear.html">Dropbear SSH</a>
server on demand on port 22 (default ssh/tcp port in <code>/etc/services</code>) on
<em>all</em> interfaces except on <code>eth0</code>, which in your case is the Internet
(WAN) interface, here you want SSH to run on port 222.  Actually, you
don&rsquo;t want port 22 open at all on <code>eth0</code> &hellip; so finit takes care of this
for you!  Seriously, it just works, no need for messing about with that
nasty old <code>iptables</code> anymore!</p>

<p>The original UNIX inetd super server supported many protocols
internally, some of which may seem a bit odd today, and some have been
superseded by more modern protocols.</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Echo_Protocol">echo</a></li>
<li><a href="http://en.wikipedia.org/wiki/Character_Generator_Protocol">chargen</a></li>
<li><a href="http://en.wikipedia.org/wiki/Time_Protocol">time</a></li>
<li><a href="http://en.wikipedia.org/wiki/Daytime_Protocol">daytime</a></li>
<li><a href="http://en.wikipedia.org/wiki/Discard_Protocol">discard</a></li>
</ul>


<p>Finit currently only supports one internal/built-in standard service,
<code>time</code>.  It is built as a plugin to serve as an example of how you can
extend Finit yourself.  The time service can be called either as UDP or
TCP.  To prevent security issues, the <code>time</code> protocol is disabled by
default.  To enable it you need two things:</p>

<ol>
<li>The <code>time.so</code> plugin (built by default)</li>
<li>An <code>inetd time ...</code> line in <code>/etc/finit.conf</code></li>
</ol>


<p>Assuming you&rsquo;ve installed the default set of plugins, the following two
lines can be added:</p>

<pre><code>inetd time/udp   wait [2345] internal
inetd time/tcp nowait [2345] internal
</code></pre>

<p>This can be very useful for testing the inetd capabilities, your network
connection, or simply to get the time to a client where NTP for some
reason does not work, or is blocked.  For instance, you could have a GPS
setup on your server and distribute time to clients with the <code>time</code>
protocol.</p>

<p>To use it you need an <a href="http://www.aelius.com/njh/rdate/"><code>rdate</code></a>
client.  Users of <code>rdate</code> in BusyBox may need to be reminded that it
only supports TCP.</p>

<pre><code>$ rdate -pu 198.51.100.42
Sat Mar  7 08:48:58 CET 2015
</code></pre>

<p>For more info on Finit and its features, see the <a href="https://github.com/troglobit/finit/blob/master/README.md">README</a>.</p>

<p>Enjoy! ツ</p>

<!-- more -->


<h3>Changes</h3>

<ul>
<li>Add support for built-in inetd super server &ndash; launch services on
demand.  Supports filtering per interface and custom Inet ports.</li>
<li>Upgrade to <a href="https://github.com/troglobit/libuev">libuEv</a> v1.1.0 to better handle error conditions.</li>
<li>Allow mixed case config directives in <code>finit.conf</code></li>
<li>Add support for RFC 868 (rdate) time plugin, start as inetd service.</li>
<li>Load plugins before parsing <code>finit.conf</code>, this makes it possible to
extend finit even with configuration commands.  E.g., the <code>time.so</code>
plugin must be loaded for the <code>inetd time/tcp internal</code> service to be
accepted when parsing <code>finit.conf</code>.</li>
<li>Slight change in TTY fallback behavior, if no TTY is listed in the
system <code>finit.conf</code> first inspect the <code>console</code> setting and only if
that too is unset fall back to <code>/bin/sh</code></li>
<li>When falling back to the <code>console</code> TTY or <code>/bin/sh</code>, finit now marks
this fallback as console.  Should improve usability in some use cases.</li>
</ul>


<h3>Fixes</h3>

<ul>
<li>Revert &ldquo;Use vfork() instead of fork() before exec()&rdquo; from v1.11.  It
turned out to not work so well after all.  For instance, launching
TTYs in a background process completely blocked inetd services from
even starting up listening sockets &hellip; proper fork seems to work fine
though.  This is the casue for <em>yanking</em> the <a href="https://github.com/troglobit/finit/compare/1.10...1.11">1.11</a> release.</li>
<li>Trap segfaults caused by external plugins/callbacks in a sub-process.
This prevents a single programming mistake in by a 3rd party developer
from taking down the entire system.</li>
<li>Fix Coverity CID 56281: <code>dlopen()</code> resource leak by storing the
pointer.  For the time being we do not support unloading plugins.</li>
<li>Set hostname early, so bootstrap processes like syslog can use it.</li>
<li>Only restart <em>lost daemons</em> when recovering from a <code>SIGSTOP</code>/norespawn.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finit v1.11 Released!]]></title>
    <link href="http://troglobit.github.io/blog/2015/01/24/finit-v1-dot-11-released/"/>
    <updated>2015-01-24T16:54:23+01:00</updated>
    <id>http://troglobit.github.io/blog/2015/01/24/finit-v1-dot-11-released</id>
    <content type="html"><![CDATA[<p><strong>Update 2015-03-09</strong>: This release has unfortunately been <em>yanked</em> due
to serious regressions in launching background processes.  It has been
replaced by <a href="/blog/2015/03/06/inetd-support-in-finit-v1-dot-12/">v1.12</a></p>

<!-- more -->


<p>I&rsquo;m very pleased to announce <a href="/finit.html">Finit v1.11</a> — this is the
episode where two of my projects finally get married! ツ</p>

<h3>Changes</h3>

<ul>
<li>Now using the asynchronous <a href="https://github.com/troglobit/libuev">libuEv</a> library for handling all events:
signals, timers and listening to sockets or file descriptors.</li>
<li>Rename NEWS.md &ndash;> CHANGELOG.md, with symlinks for <code>make install</code></li>
<li>Attempt to align with <a href="http://keepachangelog.com">http://keepachangelog.com</a> for the ChangeLog</li>
<li><a href="https://travis-ci.org/troglobit/finit">Travis CI</a> now only invokes <a href="https://scan.coverity.com/projects/3545">Coverity Scan</a> from the &lsquo;dev&rsquo; branch.  This
means that all development, except documentation updates, must go into
that branch.</li>
</ul>


<h3>Fixes</h3>

<ul>
<li>Fix bug with finit dying when no <code>tty</code> is defined in <code>finit.conf</code>, now
even the fallback shell has control over its TTY, see fix in GIT
commit <a href="https://github.com/troglobit/finit/commit/dea3ae8">dea3ae8</a> for this.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release of Finit v1.9]]></title>
    <link href="http://troglobit.github.io/blog/2014/04/21/release-of-finit-v1-dot-9/"/>
    <updated>2014-04-21T16:08:30+02:00</updated>
    <id>http://troglobit.github.io/blog/2014/04/21/release-of-finit-v1-dot-9</id>
    <content type="html"><![CDATA[<p>Just made it!  Here&rsquo;s the result of #Easterhack14 &ndash;
<a href="/finit.html">Finit</a> v1.9 :-)</p>

<p>Nothing fancy this time, just collecting some bug fixes, playing with
cppcheck a bit and adding support for including .conf files.  Quite
useful if you want to partition your configuration, or if you share
major pieces of configuration between different platforms.</p>

<p>Enjoy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finit v1.8]]></title>
    <link href="http://troglobit.github.io/blog/2013/06/08/finit-v1-dot-8/"/>
    <updated>2013-06-08T00:04:00+02:00</updated>
    <id>http://troglobit.github.io/blog/2013/06/08/finit-v1-dot-8</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been a long time coming, but here it finally is, <a href="/finit.html">Finit</a>
<a href="ftp://troglobit.com/finit/finit-1.8.tar.xz">v1.8</a>!  The goodies we&rsquo;ve been waiting for are:</p>

<ul>
<li>Runlevels</li>
<li>Multiple TTYs</li>
<li>One-shot tasks</li>
</ul>


<p>Let&rsquo;s start off with tasks.  Tasks are one-shot commands, with a
syntax like service directives, but are not monitored and respawned
like services.  Tasks are started in parallel, just like services.
For some cases, like the system bootstrap phase, some tasks may need
to be executed in sequence, and for that purpose there also exists a
run command.  Run commands are executed in the order listed in
finit.conf and will run until completion before continuing with the
next task or service.</p>

<p>Multiple TTYs is another neat feature.  Similar to services many TTYs
can be started and automatically be respawned when a user logs out.
For embedded targets wanting to save CPU cycles usually one TTY is the
system console.  Use the console command to point to a defined TTY to
activate &ldquo;Press any key to activate this console.&rdquo;</p>

<p>Finally, runlevels!  This is the key feature in this release of Finit.
Adding the flexibility from SysV init, without the complexity.  This
is one of the key points of Finit &ndash; it should be simple!</p>

<pre><code>finit.conf:
    service [2345] /usr/sbin/sshd -D -- OpenSSH Daemon
</code></pre>

<p>This command tells Finit that the OpenSSH daemon should only run in
runlevel 2-5.  Finit will also respawn sshd if it should crash, just
like before.</p>

<p>Runlevels are needed in use-cases in many embedded devices.  E.g.,
bootstrap, upgrading, and regular operation.  It is completely up to
the system administrator to setup the runlevels of the product or
installation.  At boot runlevel &rsquo;S&#8217; runs, well before any networking
is up.  This is used to to one-time probing and setup of the
system. When done the runlevel defined in finit.conf, or the default
2, is started.</p>

<p>See the <a href="https://github.com/troglobit/finit/blob/master/README.md">README</a> for more information, or the code for the full
details.</p>
]]></content>
  </entry>
  
</feed>
