<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: smcroute | Troglobit]]></title>
  <link href="http://troglobit.github.io/blog/categories/smcroute/atom.xml" rel="self"/>
  <link href="http://troglobit.github.io/"/>
  <updated>2015-01-02T12:13:29+01:00</updated>
  <id>http://troglobit.github.io/</id>
  <author>
    <name><![CDATA[Joachim Nilsson]]></name>
    <email><![CDATA[troglobit@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Threads vs Events]]></title>
    <link href="http://troglobit.github.io/blog/2013/08/06/event-handling/"/>
    <updated>2013-08-06T14:20:00+02:00</updated>
    <id>http://troglobit.github.io/blog/2013/08/06/event-handling</id>
    <content type="html"><![CDATA[<p>This is a rant about something I recently found to be a long standing
battle line in the world of programming,
<a href="http://cgi.di.uoa.gr/~mema/courses/mde518/papers/lauer78.pdf">Lau78</a>.
The event vs thread based approach to programming.  As rants go I do
not aspire to deliver a clear or logical message, what so ever.  It&rsquo;s
basically just something I need to get off my chest.</p>

<p>It was not until 2007 I first learned about the event based approach
to programming and event libraries like
<a href="http://libevent.org/">libevent</a> and
<a href="http://software.schmorp.de/pkg/libev.html">libev</a>.  Up until that
point the silver bullet everyone was using was &hellip; Threads.</p>

<p>I don&rsquo;t really know when it all started, maybe it was the Linux
revolution, the first NPTL release with GLIBC, Java or Solaris.
Nevertheless, from my point of view it was sometime in the mid 90&rsquo;s
during my time at university that the use of threads was starting to
become prevalent.</p>

<p>Surround your pullquote like this {&#8221; text to be quoted &#8220;}</p>

<p>Of course I knew about the event based approach, but it was more or
less dismissed as a thing of the past, a while(1) loop to mimic the
behavior of PLC&rsquo;s.  So almost every program I wrote, and every program
I took over from others, were like Indiana Jones types of mazes full
of deadlocks and race conditions.</p>

<p>I thought I did something wrong, and so did many others like me.  I
spent days and nights trying to understand, refactor, and redesign
threaded programs.  What I found was a doubt that the thread based
model actually didn&rsquo;t suit every problem,
<a href="http://www.cc.gatech.edu/classes/AY2009/cs4210_fall/papers/ousterhout-threads.pdf">Ous96</a>.
There are quite a few domains, however, where thread based models
shine. Usually in languages that come with thread support built-in,
like Erlang.</p>

<p>Most of the programs I work with today are network daemons.  Meaning
they are essentially message based applications that spend a lot of
time waiting for an event to occur: receiving a data frame, waiting
for a timer to expire, a signal to be raised, etc.  Of course threads
can be used for this, but it is a lot simpler to employ an event based
framework instead.  Also, they are all written in C for speed and
portability between different UNIX systems.  For that domain, where I
currently make my living, it will be difficult to convince me to ever
look at threads again.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Open Source Releases]]></title>
    <link href="http://troglobit.github.io/blog/2013/07/12/new-open-source-releases/"/>
    <updated>2013-07-12T16:30:00+02:00</updated>
    <id>http://troglobit.github.io/blog/2013/07/12/new-open-source-releases</id>
    <content type="html"><![CDATA[<p>Vacation time means catching up on my Open Source projects! :)</p>

<p>Currently I&rsquo;m shaping up the home pages and this blog to improve the
easy access and overview of all the packages I maintain.  The
following packages have new releases, or can expect new releases soon:</p>

<ul>
<li> <a href="/editline.html">Minix Editline</a> v1.14.1</li>
<li> <a href="/smcroute.html">SMCRoute</a> v1.99.1 &ndash; There&rsquo;s even a v2.0.0 being
 planned, with the core of SMCRoute available as a library</li>
<li> <a href="/mrouted.html">mrouted</a> minor cleanup an sync with
 <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/mrouted/">OpenBSD</a></li>
<li> <a href="/pimd.html">pimd</a> cleanups and bug fixes, needs testing</li>
<li> <a href="/inadyn.html">inadyn</a> is in dire need of a release, but needs more testing and fixes</li>
</ul>


<p>As usual, see my <a href="http://github.com/troglobit">GitHub</a> for the latest
commits if you want to try anything out, file an issue report, or if
you want to contribute.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multicast HowTo]]></title>
    <link href="http://troglobit.github.io/blog/2013/07/09/multicast-howto/"/>
    <updated>2013-07-09T21:00:00+02:00</updated>
    <id>http://troglobit.github.io/blog/2013/07/09/multicast-howto</id>
    <content type="html"><![CDATA[<p>The below setup is done using four Ubuntu 12.04 LTS virtual machines
running the linux-virtual kernel package.  In the HowTo I mention both
<a href="/pimd.html">pimd</a> and <a href="/mrouted.html">mrouted</a>, since they work
out-of-the-box w/o any config changes, but you could just as easily
use <a href="/smcroute.html">SMCRoute</a> for the same purpose.</p>

<p>When setting up virtual machines and virtual networking there are
several requirements for the host.  The most important one, that needs
pointing out, is a bug in the IGMP snooping code in the Linux bridging
code: the bridge handles the special case 224.0.0.* well, but all
unknown multicast streams outside of that segment should also be
forwarded as-is to all multicast routers.  Since this does not work
with the current IGMP snooping code in the Linux kernel bridge code
you must disable snooping:</p>

<pre><code>host# echo 0 &gt; /sys/devices/virtual/net/virbr1/bridge/multicast_snooping
host# echo 0 &gt; /sys/devices/virtual/net/virbr2/bridge/multicast_snooping
host# echo 0 &gt; /sys/devices/virtual/net/virbr3/bridge/multicast_snooping
</code></pre>

<p>Disabling IGMP snooping on the hosts&#8217; virbr3 is not really necessary,
but is done anyway for completeness, and also because I re-use the
same setup in other test cases as well.</p>

<pre><code> R1                       R2                       R3                       R4
+-------+                +-------+                +-------+                +-------+
|eth0   | 172.16.12.0/24 |eth0   | 172.16.10.0/24 |eth0   |  10.1.0.0/24   |eth0   |
|     .1|----------------|.2   .1|----------------|.2   .1|----------------|.2     |
|   eth1|     virbr1     |   eth1|     virbr2     |   eth1|    virbr3      |       |
+-------+                +-------+                +-------+                +-------+
</code></pre>

<p>This setup can be used in two separate use cases, remember there is only
one multicast routing socket, so you have to choose one of:</p>

<ol>
<li>. pimd -c pimd.conf</li>
<li>. mrouted -c mrouted.conf</li>
<li>. smcroute -f smcroute.conf</li>
</ol>


<p>The default configuration files delivered with pimd and mrouted usually
suffice, see their respective manual pages or the comments in each .conf
file for help.</p>

<p>When you start mrouted, you&rsquo;re usually ready to go immediately.  But
in the case of pimd, wait for routers to peer.  Then you can test your
setup using ping from R1 to a tcpdump on R4:</p>

<pre><code>R1# ping -I eth1 -t 3 225.1.2.3
R4# tcpdump -i eth0
</code></pre>

<p>As soon as the PIM routers R2 and R3 have peered you should start seeing
ICMP traffic reaching R4.</p>

<p>Now, to the actual test case.  The first command for R1 adds a route for
all multicast packets, that is necessary for all tools where you cannot
set the outbound interface for the multicast stream, in our case iperf.</p>

<pre><code>R1# ip route add 224.0.0.0/4 dev eth1
R1# iperf -u -c 225.1.2.3 -T 3
R4# iperf -s -u -B 225.1.2.3
</code></pre>

<p>The -T option is important since it tells iperf to raise the TTL to 3,
the default TTL for multicast is otherwise 1 due to its broadcast like
nature.</p>

<p>The desired output from iperf is as follows:</p>

<pre><code>R1# iperf -u -c 225.1.2.3 -T 3
------------------------------------------------------------
Client connecting to 225.1.2.3, UDP port 5001
Sending 1470 byte datagrams
Setting multicast TTL to 3
UDP buffer size:  160 KByte (default)
------------------------------------------------------------
[  3] local 172.16.12.1 port 55731 connected with 225.1.2.3 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec  1.25 MBytes  1.05 Mbits/sec
[  3] Sent 893 datagrams

R4# iperf -s -u -B 225.1.2.3
------------------------------------------------------------
Server listening on UDP port 5001
Binding to local address 225.1.2.3
Joining multicast group  225.1.2.3
Receiving 1470 byte datagrams
UDP buffer size:  160 KByte (default)
------------------------------------------------------------
[  3] local 225.1.2.3 port 5001 connected with 172.16.12.1 port 55731
[ ID] Interval       Transfer     Bandwidth        Jitter   Lost/Total Datagrams
[  3]  0.0-10.0 sec  1.25 MBytes  1.05 Mbits/sec   0.268 ms    0/  893 (0%)
</code></pre>

<p>To achieve the same using <a href="/smcroute.html">SMCRoute</a> you need to setup
the multicast routing rules manually.  The by far easiest way to do
this is to update <code>/etc/smcroute.conf</code> and and start/restart smcroute,
or send SIGHUP to an already running daemon.  The below example makes
use of the source-less (*,G) approach, since we in our limited setup
have full control over all multicast senders.  There is a slight setup
cost associated with this: the time it takes the kernel to notify
SMCRoute about a new source and before the the actual multicast route
is written to the kernel.  In most cases this is acceptable.</p>

<p>In <code>smcroute.conf</code> on R2:
    mgroup from eth0 group 225.1.2.3
    mroute from eth0 group 225.1.2.3 to eth1</p>

<p>In <code>smcroute.conf</code> on R3:
    mgroup from eth0 group 225.1.2.3
    mroute from eth0 group 225.1.2.3 to eth1</p>

<p>Now, start smcroute on each of R2 and R4 and then proceed to start
iperf on R4 and R1, as described above. You should get the same result
as with mrouted and pimd.</p>

<p>That&rsquo;s it. Have fun!</p>

<h2>FAQ</h2>

<ul>
<li>It doesn&rsquo;t work? &ndash; Check the TTL.</li>
<li>It doesn&rsquo;t work? &ndash; Check the TTL!</li>
<li>It doesn&rsquo;t work? &ndash; CHECK THE TTL!</li>
<li>Why does the TTL in multicast default to 1? &ndash; Because multicast is
classified as broadcast, which inherently is dangerous.  Without
proper limitation, like switches with support for IGMP Snooping,
multicast IS broadcast.</li>
<li>It doesn&rsquo;t work? &ndash; Check your network, maybe a switch between the
sender and the receiver doesn&rsquo;t properly support IGMP Snooping.</li>
</ul>

]]></content>
  </entry>
  
</feed>
